parameters:
  additionalMSBuildArguments: ''
  displayName: ''
  skipTests: $(SkipTests)
  targetArchitecture: null
  timeoutInMinutes: 120
  InjectRuntimePrereqs: false   # If true, expect either downloaded runtime MSIs or an injected archive to be normalized
  RuntimePrereqsArchive: ''     # Optional zip containing host/hostfxr/runtime MSIs (internal validation runs)
  GenerateDummyPrereqs: false   # (Not used automatically: dummy MSIs are for local structural testing only)
  jobStrategy: null

jobs:
  - job: ${{ parameters.name }}
    displayName: ${{ parameters.displayName }}
    timeoutInMinutes: ${{ parameters.timeoutInMinutes }}
    pool:
      # Use a hosted pool when possible.
      ${{ if eq(variables['System.TeamProject'], 'public') }}:
        vmImage: 'windows-2022'
      ${{ if ne(variables['System.TeamProject'], 'public') }}:
        name: NetCore1ESPool-Internal
        demands: ImageOverride -equals windows.vs2019.amd64

    # Allow caller to override the job strategy (e.g. to add an architecture matrix).
    ${{ if ne(parameters.jobStrategy, null) }}:
      strategy: ${{ parameters.jobStrategy }}
    ${{ else }}:
      strategy:
        matrix: 
          Debug:
            _BuildConfig: Debug
          Release:
            _BuildConfig: Release

    workspace:
      clean: all
    variables: 
      - name: CommonMSBuildArgs
        value: >-
          -c $(_BuildConfig)
          /p:TargetArchitecture=$(TargetArchitecture)
          /p:SkipTests=${{ parameters.skipTests }}
          /p:ContinuousIntegrationBuild=true
      - ${{ if ne(parameters.targetArchitecture, null) }}:
        - name: TargetArchitecture
          value: ${{ parameters.targetArchitecture }}
      - ${{ if eq(parameters.targetArchitecture, null) }}:
        - name: TargetArchitecture
          value: $(TargetArchitecture)
      - ${{ if eq(variables['System.TeamProject'], 'public') }}:
        - name: MsbuildSigningArguments
          value: /p:DotNetSignType=Test
      - ${{ if ne(variables['System.TeamProject'], 'public') }}:
        - name: MsbuildSigningArguments
          value: /p:DotNetSignType=Real

    steps:
    - template: /eng/common/templates/steps/enable-internal-sources.yml

    # Diagnostic: echo important variables early to help debug public vs internal gating
    - task: PowerShell@2
      displayName: 'Diagnostic: echo System.TeamProject and TargetArchitecture'
      condition: always()
      continueOnError: true
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Diagnostic: System.TeamProject=$(System.TeamProject)"
          Write-Host "Diagnostic: TargetArchitecture=$(TargetArchitecture)"

    # Download runtime MSI artifacts from the runtime build
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Runtime MSI Artifacts'
      inputs:
        buildType: 'specific'
        project: 'internal'
        pipeline: 'dotnet-runtime-official'
        buildVersionToDownload: 'latestFromBranch'
        branchName: 'refs/heads/main'
        artifactName: 'PackageArtifacts'
        itemPattern: |
          **/**/dotnet-host-*-win-$(TargetArchitecture).msi
          **/**/dotnet-hostfxr-*-win-$(TargetArchitecture).msi
          **/**/dotnet-runtime-*-win-$(TargetArchitecture).msi
        downloadPath: '$(Build.SourcesDirectory)/artifacts/runtime-msis'
      condition: and(succeeded(), ne(variables['System.TeamProject'], 'public'))
      continueOnError: true

    # For public builds (PR), skip MSI download - we'll use VS.Redist packages as fallback
    - task: PowerShell@2
      displayName: 'Skip MSI Download for Public Build'
      condition: eq(variables['System.TeamProject'], 'public')
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Public PR build detected - runtime MSI download not available"
          Write-Host "Bundle will fall back to VS.Redist packages if available"
          New-Item -ItemType Directory -Force -Path "$(Build.SourcesDirectory)/artifacts/runtime-msis" | Out-Null

    # Optional dummy prereqs for structural testing (will NOT produce valid bundle if light validates MSI internal tables)
    - powershell: |
        if ('${{ parameters.GenerateDummyPrereqs }}' -eq 'true') {
          $arch='$(TargetArchitecture)'
          Write-Host "Generating dummy prereq runtime placeholders for $arch";
          # Call relocated script (shim remains in eng for backward compat)
          pwsh "$(Build.SourcesDirectory)/src/windowsdesktop/tests/scripts/make-dummy-runtime-msis.ps1" -Architecture $arch
        } else {
          Write-Host "GenerateDummyPrereqs not enabled.";
        }
      displayName: 'Generate Dummy Prereq Runtime MSIs'
      condition: and(eq(variables['System.TeamProject'],'public'), succeeded())

    # Optional: expand provided archive of runtime prereqs (manual/internal validation scenario)
    - powershell: |
        if ('${{ parameters.RuntimePrereqsArchive }}' -and (Test-Path '${{ parameters.RuntimePrereqsArchive }}')) {
          $arch='$(TargetArchitecture)'
          $dest = "$(Build.SourcesDirectory)/artifacts/runtime-msis/archive-$arch"
          New-Item -Force -ItemType Directory -Path $dest | Out-Null
          Write-Host "Expanding provided RuntimePrereqsArchive to $dest";
          Expand-Archive -Path '${{ parameters.RuntimePrereqsArchive }}' -DestinationPath $dest -Force
        } else {
          Write-Host "No RuntimePrereqsArchive supplied or file missing.";
        }
      displayName: 'Expand Provided RuntimePrereqsArchive'
      condition: and(succeeded(), ne(variables['System.TeamProject'], 'public'), eq('${{ parameters.InjectRuntimePrereqs }}','true'))
      continueOnError: true

    # Verify runtime MSI download and check architecture-specific files (internal builds only)
    - powershell: |
        $arch = "$(TargetArchitecture)"
        $runtimeMsiDir = "$(Build.SourcesDirectory)/artifacts/runtime-msis"
        
        Write-Host "Checking runtime MSI download results for architecture: $arch"
        
        if (Test-Path $runtimeMsiDir) {
          Write-Host "Runtime MSIs directory exists"
          $allMsis = Get-ChildItem -Path $runtimeMsiDir -Name "*.msi" -Recurse -ErrorAction SilentlyContinue
          Write-Host "All MSI files found:"
          $allMsis | ForEach-Object { Write-Host "  $_" }
          Write-Host "Total MSI files: $($allMsis.Count)"
          
          if ($allMsis.Count -gt 0) {
            # Check for required architecture-specific MSIs
            $hostMsi = Get-ChildItem -Path $runtimeMsiDir -Name "dotnet-host-*-win-$arch.msi" -Recurse -ErrorAction SilentlyContinue
            $hostfxrMsi = Get-ChildItem -Path $runtimeMsiDir -Name "dotnet-hostfxr-*-win-$arch.msi" -Recurse -ErrorAction SilentlyContinue
            $runtimeMsi = Get-ChildItem -Path $runtimeMsiDir -Name "dotnet-runtime-*-win-$arch.msi" -Recurse -ErrorAction SilentlyContinue
            
            Write-Host "Architecture-specific MSIs for $arch":""
            Write-Host "  Host MSI: $($hostMsi.Count) found"
            Write-Host "  HostFxr MSI: $($hostfxrMsi.Count) found"
            Write-Host "  Runtime MSI: $($runtimeMsi.Count) found"
            
            if ($hostMsi.Count -gt 0 -and $hostfxrMsi.Count -gt 0 -and $runtimeMsi.Count -gt 0) {
              Write-Host "All required runtime MSI files found for architecture $arch"
              # List the specific files we'll use
              $hostMsi | ForEach-Object { Write-Host "  Using Host MSI: $_" }
              $hostfxrMsi | ForEach-Object { Write-Host "  Using HostFxr MSI: $_" }
              $runtimeMsi | ForEach-Object { Write-Host "  Using Runtime MSI: $_" }
            } else {
              Write-Host "##vso[task.logissue type=warning]Some runtime MSI files missing for $arch - will fall back to VS.Redist packages"
            }
          } else {
            Write-Host "##vso[task.logissue type=warning]No runtime MSI files found - will fall back to VS.Redist packages"
          }
        } else {
          Write-Host "##vso[task.logissue type=warning]Runtime MSIs directory does not exist - will fall back to VS.Redist packages"
        }
      displayName: 'Verify Runtime MSI Download for $(TargetArchitecture)'
      condition: succeededOrFailed()

    # Normalize runtime MSIs into deterministic prereqs directory (internal builds only)
    - powershell: |
        $arch = "$(TargetArchitecture)"
        $downloadRoot = "$(Build.SourcesDirectory)/artifacts/runtime-msis"
        $prereqDir = "$(Build.SourcesDirectory)/artifacts/prereqs/$arch"
        New-Item -Force -ItemType Directory -Path $prereqDir | Out-Null
        Write-Host "Normalizing runtime MSIs for architecture $arch";
        function PickLatest($pattern) {
          Get-ChildItem -Path $downloadRoot -Recurse -Filter $pattern -ErrorAction SilentlyContinue | Sort-Object Name -Descending | Select-Object -First 1
        }
        $host    = PickLatest "dotnet-host-*-win-$arch.msi"
        $hostfxr = PickLatest "dotnet-hostfxr-*-win-$arch.msi"
        $runtime = PickLatest "dotnet-runtime-*-win-$arch.msi"
        if ($host -and $hostfxr -and $runtime) {
          Copy-Item $host.FullName    (Join-Path $prereqDir "dotnet-host-win-$arch.msi") -Force
          Copy-Item $hostfxr.FullName (Join-Path $prereqDir "dotnet-hostfxr-win-$arch.msi") -Force
          Copy-Item $runtime.FullName (Join-Path $prereqDir "dotnet-runtime-win-$arch.msi") -Force
          "RuntimePrereqVersion=" + ($runtime.BaseName) | Out-File (Join-Path $prereqDir "resolved-runtime-version.txt") -Encoding UTF8
          Write-Host "Staged prerequisite runtime MSIs:";
          Get-ChildItem $prereqDir -Filter "dotnet-*-win-$arch.msi" | Select-Object Name,Length
        } else {
          Write-Host "##vso[task.logissue type=warning]Incomplete runtime MSIs for $arch; will build bundle without prereqs."
        }
      displayName: 'Normalize Runtime Prereq MSIs ($(TargetArchitecture))'
      condition: and(succeededOrFailed(), ne(variables['System.TeamProject'], 'public'))
      continueOnError: true

    # Copy MSIs to expected location for bundle build (if any were downloaded)
    - task: CopyFiles@2
      displayName: 'Stage Runtime MSIs for Bundle'
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)/artifacts/runtime-msis'
        Contents: '**/*.msi'
        TargetFolder: '$(Build.SourcesDirectory)/artifacts/packages/$(_BuildConfig)/Shipping'
        flattenFolders: true
      condition: succeeded()
      continueOnError: true

    # Verify staging location has architecture-specific MSIs
    - powershell: |
        $arch = "$(TargetArchitecture)"
        $stagingDir = "$(Build.SourcesDirectory)/artifacts/prereqs/$arch"
        
        Write-Host "Checking normalized prerequisite runtime MSIs for architecture: $arch"
        Write-Host "Prereqs directory: $stagingDir"
        
        if (Test-Path $stagingDir) {
          Write-Host "Staging directory exists"
          $stagedMsis = Get-ChildItem -Path $stagingDir -Name "dotnet-*-win-$arch.msi" -ErrorAction SilentlyContinue
          if ($stagedMsis) {
            Write-Host "Prereq runtime MSI files:"; $stagedMsis | ForEach-Object { Write-Host "  $_" }
          } else { Write-Host "No normalized prereq runtime MSIs present." }
          
          if ($stagedMsis.Count -gt 0 -and $stagedMsis.Count -ne 3) {
            Write-Host "##vso[task.logissue type=warning]Expected 3 runtime prereq MSIs for $arch, found $($stagedMsis.Count)"
          }
        } else {
          Write-Host "Prereqs directory not present (acceptable for public builds)."
        }
      displayName: 'Verify Prerequisite Runtime MSIs ($(TargetArchitecture))'
      condition: succeededOrFailed()

    - ${{ if ne(variables['System.TeamProject'], 'public') }}:
      - task: MicroBuildSigningPlugin@4
        displayName: Install MicroBuild plugin for Signing
        inputs:
          signType: $(SignType)
          zipSources: false
          feedSource: https://dnceng.pkgs.visualstudio.com/_packaging/MicroBuildToolset/nuget/v3/index.json
        continueOnError: false
        condition: and(succeeded(), in(variables['SignType'], 'real', 'test'))

    - script: >-
        eng/common/cibuild.cmd
        $(CommonMSBuildArgs)
        $(MsbuildSigningArguments)
      displayName: Build

    - ${{ if ne(parameters.skipTests, 'true') }}:
      - task: PublishTestResults@2
        displayName: Publish Test Results
        inputs:
          testResultsFormat: 'xUnit'
          testResultsFiles: '*.xml'
          searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
          mergeTestResults: true
          testRunTitle: ${{ parameters.name }}-$(_BuildConfig)
        continueOnError: true
        condition: always()

    - task: PowerShell@2
      displayName: 'Gather and upload logs'
      condition: always()
      continueOnError: true
      script: |
        $logDirectories = @(
            "$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)",
            "$(Build.sourcesdirectory)/artifacts/TestResults/$(_BuildConfig)"
        )

        $stagingDirectory = "$(Build.ArtifactStagingDirectory)/Logs-$(_BuildConfig)"
        New-Item -ItemType Directory -Path $stagingDirectory -Force

        foreach ($dir in $logDirectories) {
            if (Test-Path $dir) {
                Write-Host "Copying logs from $dir"
                Copy-Item -Path "$dir/*" -Destination $stagingDirectory -Recurse -Force -ErrorAction SilentlyContinue
            } else {
                Write-Host "Log directory not found (this is okay if no tests ran or build failed early): $dir"
            }
        }
        Write-Host "Staged logs in $stagingDirectory"
        Get-ChildItem $stagingDirectory -Recurse | Select-Object FullName

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Logs ($(_BuildConfig))'
      condition: always()
      continueOnError: true
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/Logs-$(_BuildConfig)'
        ArtifactName: 'Logs_${{ parameters.name }}_$(_BuildConfig)'
