parameters:
  additionalMSBuildArguments: ''
  displayName: ''
  skipTests: $(SkipTests)
  targetArchitecture: null
  timeoutInMinutes: 120

jobs:
  - job: ${{ parameters.name }}
    displayName: ${{ parameters.displayName }}
    timeoutInMinutes: ${{ parameters.timeoutInMinutes }}
    pool:
      # Use a hosted pool when possible.
      ${{ if eq(variables['System.TeamProject'], 'public') }}:
        vmImage: 'windows-2022'
      ${{ if ne(variables['System.TeamProject'], 'public') }}:
        name: NetCore1ESPool-Internal
        demands: ImageOverride -equals windows.vs2019.amd64
    strategy:
      matrix: 
        Debug:
          _BuildConfig: Debug
        Release:
          _BuildConfig: Release
    workspace:
      clean: all
    variables: 
      - name: CommonMSBuildArgs
        value: >-
          -c $(_BuildConfig)
          /p:TargetArchitecture=${{ parameters.targetArchitecture }}
          /p:SkipTests=${{ parameters.skipTests }}
      - name: TargetArchitecture
        value: ${{ parameters.targetArchitecture }}
      - ${{ if eq(variables['System.TeamProject'], 'public') }}:
        - name: MsbuildSigningArguments
          value: /p:DotNetSignType=Test
      - ${{ if ne(variables['System.TeamProject'], 'public') }}:
        - name: MsbuildSigningArguments
          value: /p:DotNetSignType=Real

    steps:
    - template: /eng/common/templates/steps/enable-internal-sources.yml

    # Download runtime MSI artifacts from the runtime build
    # Use latest since version-specific builds may not always be available
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Runtime MSI Artifacts'
      inputs:
        buildType: 'specific'
        project: 'internal'
        pipeline: 'dotnet-runtime-official'
        buildVersionToDownload: 'latestFromBranch'
        branchName: 'refs/heads/main'
        artifactName: 'PackageArtifacts'
        itemPattern: |
          **/**/dotnet-host-*-win-${{ parameters.targetArchitecture }}.msi
          **/**/dotnet-hostfxr-*-win-${{ parameters.targetArchitecture }}.msi
          **/**/dotnet-runtime-*-win-${{ parameters.targetArchitecture }}.msi
        downloadPath: '$(Build.SourcesDirectory)/artifacts/runtime-msis'
      condition: and(succeeded(), ne(variables['System.TeamProject'], 'public'))
      continueOnError: false
      retryCountOnTaskFailure: 3

    # Verify runtime MSI download and check architecture-specific files
    - powershell: |
        $arch = "${{ parameters.targetArchitecture }}"
        $runtimeMsiDir = "$(Build.SourcesDirectory)/artifacts/runtime-msis"
        
        Write-Host "Checking runtime MSI download results for architecture: $arch"
        
        if (Test-Path $runtimeMsiDir) {
          Write-Host "Runtime MSIs directory exists"
          $allMsis = Get-ChildItem -Path $runtimeMsiDir -Name "*.msi" -Recurse
          Write-Host "All MSI files found:"
          $allMsis | ForEach-Object { Write-Host "  $_" }
          Write-Host "Total MSI files: $($allMsis.Count)"
          
          # Check for required architecture-specific MSIs
          $hostMsi = Get-ChildItem -Path $runtimeMsiDir -Name "dotnet-host-*-win-$arch.msi" -Recurse
          $hostfxrMsi = Get-ChildItem -Path $runtimeMsiDir -Name "dotnet-hostfxr-*-win-$arch.msi" -Recurse
          $runtimeMsi = Get-ChildItem -Path $runtimeMsiDir -Name "dotnet-runtime-*-win-$arch.msi" -Recurse
          
          Write-Host "Architecture-specific MSIs for $arch"":""
          Write-Host "  Host MSI: $($hostMsi.Count) found"
          Write-Host "  HostFxr MSI: $($hostfxrMsi.Count) found"
          Write-Host "  Runtime MSI: $($runtimeMsi.Count) found"
          
          if ($hostMsi.Count -eq 0 -or $hostfxrMsi.Count -eq 0 -or $runtimeMsi.Count -eq 0) {
            Write-Host "##vso[task.logissue type=error]Missing required runtime MSI files for architecture $arch"
            Write-Host "##vso[task.complete result=Failed]"
            exit 1
          } else {
            Write-Host "All required runtime MSI files found for architecture $arch"
            # List the specific files we'll use
            $hostMsi | ForEach-Object { Write-Host "  Using Host MSI: $_" }
            $hostfxrMsi | ForEach-Object { Write-Host "  Using HostFxr MSI: $_" }
            $runtimeMsi | ForEach-Object { Write-Host "  Using Runtime MSI: $_" }
          }
        } else {
          Write-Host "##vso[task.logissue type=error]Runtime MSIs directory does not exist: $runtimeMsiDir"
          Write-Host "##vso[task.complete result=Failed]"
          exit 1
        }
      displayName: 'Verify Runtime MSI Download for ${{ parameters.targetArchitecture }}'
      condition: and(succeededOrFailed(), ne(variables['System.TeamProject'], 'public'))

    # Copy MSIs to expected location for bundle build
    - task: CopyFiles@2
      displayName: 'Stage Runtime MSIs for Bundle'
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)/artifacts/runtime-msis'
        Contents: '**/*.msi'
        TargetFolder: '$(Build.SourcesDirectory)/artifacts/packages/$(_BuildConfig)/Shipping'
        flattenFolders: true
      condition: and(succeeded(), ne(variables['System.TeamProject'], 'public'))
      continueOnError: false

    # Verify staging location has architecture-specific MSIs
    - powershell: |
        $arch = "${{ parameters.targetArchitecture }}"
        $stagingDir = "$(Build.SourcesDirectory)/artifacts/packages/$(_BuildConfig)/Shipping"
        
        Write-Host "Checking staged runtime MSIs for architecture: $arch"
        Write-Host "Staging directory: $stagingDir"
        
        if (Test-Path $stagingDir) {
          Write-Host "Staging directory exists"
          $stagedMsis = Get-ChildItem -Path $stagingDir -Name "dotnet-*.msi"
          Write-Host "All staged runtime MSI files:"
          $stagedMsis | ForEach-Object { Write-Host "  $_" }
          Write-Host "Total runtime MSI files staged: $($stagedMsis.Count)"
          
          # Verify we have the specific architecture files
          $archSpecificMsis = $stagedMsis | Where-Object { $_ -like "*-win-$arch.msi" }
          Write-Host "Architecture-specific MSIs for $arch" ": $($archSpecificMsis.Count)"
          $archSpecificMsis | ForEach-Object { Write-Host "  $_" }
          
          if ($archSpecificMsis.Count -lt 3) {
            Write-Host "##vso[task.logissue type=warning]Expected 3 runtime MSI files for $arch, found $($archSpecificMsis.Count)"
          }
        } else {
          Write-Host "##vso[task.logissue type=error]Staging directory does not exist: $stagingDir"
        }
      displayName: 'Verify Runtime MSI Staging for ${{ parameters.targetArchitecture }}'
      condition: and(succeededOrFailed(), ne(variables['System.TeamProject'], 'public'))

    - ${{ if ne(variables['System.TeamProject'], 'public') }}:
      - task: MicroBuildSigningPlugin@4
        displayName: Install MicroBuild plugin for Signing
        inputs:
          signType: $(SignType)
          zipSources: false
          feedSource: https://dnceng.pkgs.visualstudio.com/_packaging/MicroBuildToolset/nuget/v3/index.json
        continueOnError: false
        condition: and(succeeded(), in(variables['SignType'], 'real', 'test'))

    - script: >-
        eng/common/cibuild.cmd
        $(CommonMSBuildArgs)
        $(MsbuildSigningArguments)
      displayName: Build

    - ${{ if ne(parameters.skipTests, 'true') }}:
      - task: PublishTestResults@2
        displayName: Publish Test Results
        inputs:
          testResultsFormat: 'xUnit'
          testResultsFiles: '*.xml'
          searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
          mergeTestResults: true
          testRunTitle: ${{ parameters.name }}-$(_BuildConfig)
        continueOnError: true
        condition: always()

    - task: CopyFiles@2
      displayName: Prepare BuildLogs staging directory
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)'
        Contents: |
          **/*.log
          **/*.binlog
        TargetFolder: '$(Build.StagingDirectory)/BuildLogs'
        CleanTargetFolder: true
      continueOnError: true
      condition: succeededOrFailed()

    - task: PublishBuildArtifacts@1
      displayName: Publish BuildLogs
      inputs:
        PathtoPublish: '$(Build.StagingDirectory)/BuildLogs'
        ArtifactName: Logs-${{ parameters.name }}-$(_BuildConfig)
      continueOnError: true
      condition: succeededOrFailed()
