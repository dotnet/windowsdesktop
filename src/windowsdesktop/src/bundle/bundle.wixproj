<Project Sdk="Microsoft.WixToolset.Sdk">

  <PropertyGroup>
    <!-- OutputType determines the extension, .msi, .wixlib, .exe, etc. -->
    <OutputType>Bundle</OutputType>
    
    <!-- Enable WiX v5 features (following reference repo pattern) -->
    <UseWix5>true</UseWix5>
    
    <!-- WiX v5 build configuration -->
    <WixBuildExecutablesFolder>$(PkgMicrosoft_Wix)\tools\net6.0\</WixBuildExecutablesFolder>
    <WixExtensionDirectory>$(PkgMicrosoft_Wix)\tools\net6.0\</WixExtensionDirectory>
    
    <!-- Bundle platform configuration -->
    <BundlePlatform Condition="'$(TargetArchitecture)' == 'x86'">x86</BundlePlatform>
    <BundlePlatform Condition="'$(TargetArchitecture)' == 'x64'">x64</BundlePlatform>
    <BundlePlatform Condition="'$(TargetArchitecture)' == 'arm64'">arm64</BundlePlatform>
    
    <!-- Set InstallerPlatform to match TargetArchitecture if not already set -->
    <InstallerPlatform Condition="'$(InstallerPlatform)' == ''">$(TargetArchitecture)</InstallerPlatform>
    
    <!-- Version information for the bundle executable -->
    <AssemblyTitle>Microsoft Windows Desktop Runtime Installer</AssemblyTitle>
    <AssemblyDescription>Microsoft Windows Desktop Runtime $(Version) Installer</AssemblyDescription>
    <AssemblyCompany>Microsoft Corporation</AssemblyCompany>
    <AssemblyProduct>Microsoft Windows Desktop Runtime</AssemblyProduct>
    <AssemblyCopyright>Â© Microsoft Corporation. All rights reserved.</AssemblyCopyright>
    <AssemblyInformationalVersion>$(Version)</AssemblyInformationalVersion>
    <AssemblyFileVersion>$(Version)</AssemblyFileVersion>
    <AssemblyVersion>$(Version)</AssemblyVersion>
    
    <!-- WiX v5 PDB configuration - bundles don't publish PDBs -->
    <WixToolsetCompilerPdbType>full</WixToolsetCompilerPdbType>
    <PublishWindowsPdb>false</PublishWindowsPdb>
    <NoWarn>$(NoWarn);WIX1098</NoWarn>

    <!-- Globbing will automatically find any .wxl relative to the project file. Since we're simshipping localized content for
         the bundle UI, we either need to exclude the .wxl files or place them in a directory outside of the project. For simshipping
         we only need to ensure the files are pulled in as additional payloads into the UX container. -->
    <DefaultItemExcludes>$(DefaultItemExcludes);LCID\**\*;theme\**\*</DefaultItemExcludes>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="$(PkgMicrosoft_DotNet_Build_Tasks_Installers)\build\wix5\bundle\upgradePolicies.wxs" />
    <Compile Include="dotnet-packages.wxs" />

    <!-- Workload manifests will be included only if the source fragment was generated. -->
    <Compile Include="$(WorkloadManifestsWxsPath)" Condition="'$(WorkloadManifestsWxsPath)' != '' AND Exists('$(WorkloadManifestsWxsPath)')" />
  </ItemGroup>

  <ItemGroup>
    <!-- Microsoft.Wix is a dotnet tool package, so exclude its assets (following reference repo pattern) -->
    <PackageReference Include="Microsoft.Wix" ExcludeAssets="all" />
    <!-- WiX extension packages with GeneratePathProperty for installers -->
    <PackageReference Include="Microsoft.WixToolset.UI.wixext" GeneratePathProperty="true" />
    <PackageReference Include="Microsoft.WixToolset.Dependency.wixext" GeneratePathProperty="true" />
    <PackageReference Include="Microsoft.WixToolset.Util.wixext" GeneratePathProperty="true" />
    <PackageReference Include="Microsoft.WixToolset.Bal.wixext" GeneratePathProperty="true" />
    <PackageReference Include="Microsoft.WixToolset.Heat" />
    
    <!-- WindowsDesktop transport package containing runtime MSI components -->
    <PackageReference Include="Microsoft.Internal.Runtime.WindowsDesktop.Transport" 
                      GeneratePathProperty="true" />
  </ItemGroup>

  <ItemGroup>
    <!-- Ensure the Windows Desktop Runtime is built before this bundle -->
    <ProjectReference Include="..\sfx\Microsoft.WindowsDesktop.App.Runtime.sfxproj" />
  </ItemGroup>

  <!-- Collect .NET Core runtime components from transport packages and local build artifacts -->
  <Target Name="GetBundledNETCoreRuntimeMsiFiles" BeforeTargets="SetInstallerInfo">
    <!-- Use transport package first (for CI), then fallback to local artifacts -->
    <PropertyGroup>
      <_TransportPackagePath>$(PkgMicrosoft_Internal_Runtime_WindowsDesktop_Transport)</_TransportPackagePath>
    </PropertyGroup>

    <ItemGroup>
      <!-- Look for .NET runtime component MSI files in transport package first -->
      <DotNetHostMsiCandidate Include="$(_TransportPackagePath)\**\dotnet-host-*-win-$(TargetArchitecture).msi" Condition="'$(_TransportPackagePath)' != ''" />
      <DotNetHostFxrMsiCandidate Include="$(_TransportPackagePath)\**\dotnet-hostfxr-*-win-$(TargetArchitecture).msi" Condition="'$(_TransportPackagePath)' != ''" />
      <DotNetRuntimeMsiCandidate Include="$(_TransportPackagePath)\**\dotnet-runtime-*-win-$(TargetArchitecture).msi" Condition="'$(_TransportPackagePath)' != ''" />
      
      <!-- Fallback to local build artifacts if transport package not available -->
      <DotNetHostMsiCandidate Include="$(ArtifactsPackagesDir)Shipping\dotnet-host-*-win-$(TargetArchitecture).msi" Condition="'$(_TransportPackagePath)' == ''" />
      <DotNetHostFxrMsiCandidate Include="$(ArtifactsPackagesDir)Shipping\dotnet-hostfxr-*-win-$(TargetArchitecture).msi" Condition="'$(_TransportPackagePath)' == ''" />
      <DotNetRuntimeMsiCandidate Include="$(ArtifactsPackagesDir)Shipping\dotnet-runtime-*-win-$(TargetArchitecture).msi" Condition="'$(_TransportPackagePath)' == ''" />
    </ItemGroup>

    <!-- Select first available MSI from each group -->
    <PropertyGroup>
      <DotNetHostMsiPath>@(DotNetHostMsiCandidate -> '%(FullPath)', ';')</DotNetHostMsiPath>
      <DotNetHostFxrMsiPath>@(DotNetHostFxrMsiCandidate -> '%(FullPath)', ';')</DotNetHostFxrMsiPath>
      <DotNetRuntimeMsiPath>@(DotNetRuntimeMsiCandidate -> '%(FullPath)', ';')</DotNetRuntimeMsiPath>
    </PropertyGroup>

    <!-- Take first item from semicolon-separated list -->
    <PropertyGroup>
      <DotNetHostMsiPath Condition="$(DotNetHostMsiPath.Contains(';'))">$(DotNetHostMsiPath.Split(';')[0])</DotNetHostMsiPath>
      <DotNetHostFxrMsiPath Condition="$(DotNetHostFxrMsiPath.Contains(';'))">$(DotNetHostFxrMsiPath.Split(';')[0])</DotNetHostFxrMsiPath>
      <DotNetRuntimeMsiPath Condition="$(DotNetRuntimeMsiPath.Contains(';'))">$(DotNetRuntimeMsiPath.Split(';')[0])</DotNetRuntimeMsiPath>
    </PropertyGroup>
  </Target>

  <Target Name="SetInstallerInfo" BeforeTargets="CoreCompile" DependsOnTargets="GetBundledNETCoreRuntimeMsiFiles">
    <PropertyGroup>
      <!-- Essential bundle metadata -->
      <DefineConstants>$(DefineConstants);Version=$(MajorVersion).$(MinorVersion).$(PatchVersion)</DefineConstants>
      <DefineConstants>$(DefineConstants);BundleVersion=$(Version)</DefineConstants>
      <DefineConstants>$(DefineConstants);Manufacturer=Microsoft Corporation</DefineConstants>
      <DefineConstants>$(DefineConstants);SdkBrandName=Microsoft Windows Desktop Runtime</DefineConstants>
      
      <!-- Generate UpgradeCodes with major version for proper upgrade behavior -->
      <!-- In-place upgrades within major.minor versions, SxS across major versions -->
      <!-- IMPORTANT: RC1 used UpgradeCode {39A4DBC3-2C46-4F31-9C0D-E4B1B4B526DE} - seed should generate this -->
      <UpgradeCodeSeed>Windows Desktop Shared Framework Bundle Installer</UpgradeCodeSeed>
      <!-- WiX v5 generates different GUIDs than WiX v3 - can't match RC1 exactly -->
      <!-- Use consistent seed for WiX v5 going forward with arch for SxS support -->
      <UpgradeCodeSeedWithArch>$(UpgradeCodeSeed) $(TargetArchitecture) $(MajorVersion).$(MinorVersion)</UpgradeCodeSeedWithArch>
      
      <!-- Architecture and platform -->
      <DefineConstants>$(DefineConstants);TargetArchitecture=$(TargetArchitecture)</DefineConstants>
      <DefineConstants>$(DefineConstants);PlatformToken=$(TargetArchitecture.ToUpper())</DefineConstants>
      <DefineConstants>$(DefineConstants);NativeMachine_x64=x64</DefineConstants>
      <DefineConstants>$(DefineConstants);NativeMachine_arm64=arm64</DefineConstants>

      <!-- Version information -->
      <DefineConstants>$(DefineConstants);MajorVersion=$(MajorVersion)</DefineConstants>
      <DefineConstants>$(DefineConstants);MinorVersion=$(MinorVersion)</DefineConstants>
      <DefineConstants>$(DefineConstants);VERSIONMAJOR=$(MajorVersion)</DefineConstants>
      <DefineConstants>$(DefineConstants);VERSIONMINOR=$(MinorVersion)</DefineConstants>
      <DefineConstants>$(DefineConstants);WinFormsAndWpfVersion=$(WinFormsAndWpfVersion)</DefineConstants>
      <DefineConstants>$(DefineConstants);DotNetRuntimeVersion=$(DotNetRuntimeVersion)</DefineConstants>
      <DefineConstants>$(DefineConstants);AspNetCoreVersion=$(AspNetCoreVersion)</DefineConstants>
      <DefineConstants>$(DefineConstants);MinimumVSVersion=$(MinimumVSVersion)</DefineConstants>

      <!-- Windows Desktop Runtime MSI (always from local build) -->
      <WindowsDesktopRuntimeMsiPath>$(ArtifactsPackagesDir)Shipping\windowsdesktop-runtime-$(Version)-win-$(TargetArchitecture).msi</WindowsDesktopRuntimeMsiPath>
      
      <!-- Set MSI existence flags (simple ASP.NET Core style) -->
      <DefineConstants>$(DefineConstants);WindowsDesktopRuntimeMsiPath=$(WindowsDesktopRuntimeMsiPath)</DefineConstants>
      <DefineConstants>$(DefineConstants);DotNetHostMsiPath=$(DotNetHostMsiPath)</DefineConstants>
      <DefineConstants>$(DefineConstants);DotNetHostFxrMsiPath=$(DotNetHostFxrMsiPath)</DefineConstants>
      <DefineConstants>$(DefineConstants);DotNetRuntimeMsiPath=$(DotNetRuntimeMsiPath)</DefineConstants>
      <DefineConstants>$(DefineConstants);DotNetHostMsiExists=$([System.IO.File]::Exists('$(DotNetHostMsiPath)'))</DefineConstants>
      <DefineConstants>$(DefineConstants);DotNetHostFxrMsiExists=$([System.IO.File]::Exists('$(DotNetHostFxrMsiPath)'))</DefineConstants>
      <DefineConstants>$(DefineConstants);DotNetRuntimeMsiExists=$([System.IO.File]::Exists('$(DotNetRuntimeMsiPath)'))</DefineConstants>

      <DefineConstants Condition="'$(WorkloadManifestsWxsPath)' != '' AND Exists('$(WorkloadManifestsWxsPath)')">$(DefineConstants);IncludeWorkloadManifests=true</DefineConstants>
      <DefineConstants Condition="'$(WorkloadManifestsWxsPath)' == '' OR !Exists('$(WorkloadManifestsWxsPath)')">$(DefineConstants);IncludeWorkloadManifests=false</DefineConstants>
    </PropertyGroup>
    
    <!-- Simple logging -->
    <Message Text="Windows Desktop Runtime: $(WindowsDesktopRuntimeMsiPath) (Exists: $([System.IO.File]::Exists('$(WindowsDesktopRuntimeMsiPath)')))" Importance="high" />
    <Message Text=".NET Host: $(DotNetHostMsiPath) (Exists: $([System.IO.File]::Exists('$(DotNetHostMsiPath)')))" Importance="high" />
    <Message Text=".NET HostFxr: $(DotNetHostFxrMsiPath) (Exists: $([System.IO.File]::Exists('$(DotNetHostFxrMsiPath)')))" Importance="high" />
    <Message Text=".NET Runtime: $(DotNetRuntimeMsiPath) (Exists: $([System.IO.File]::Exists('$(DotNetRuntimeMsiPath)')))" Importance="high" />
  </Target>

  <!-- Bundle publication to shipping directory -->
  <Target Name="PublishBundle" AfterTargets="Build">
    <PropertyGroup>
      <BundleShippingName>windowsdesktop-runtime-$(Version)-win-$(TargetArchitecture).exe</BundleShippingName>
      <BundleShippingPath>$(ArtifactsPackagesDir)Shipping\$(BundleShippingName)</BundleShippingPath>
    </PropertyGroup>
    <Copy SourceFiles="$(OutputPath)$(TargetFileName)" DestinationFiles="$(BundleShippingPath)" />
    <Message Text="Published bundle: $(BundleShippingPath)" Importance="high" />
  </Target>

  <!-- Generate deterministic UpgradeCode from seed -->
  <Target Name="GenerateUpgradeCode" AfterTargets="SetInstallerInfo">
    <!-- Use Microsoft.DotNet.Build.Tasks.Installers task to generate GUID from seed -->
    <GenerateGuidFromName Name="$(UpgradeCodeSeedWithArch)">
      <Output TaskParameter="GeneratedGuid" PropertyName="GeneratedUpgradeCode" />
    </GenerateGuidFromName>
    
    <PropertyGroup>
      <DefineConstants>$(DefineConstants);UpgradeCode={$(GeneratedUpgradeCode)}</DefineConstants>
    </PropertyGroup>
    
    <Message Text="Generated UpgradeCode for $(TargetArchitecture) v$(MajorVersion).$(MinorVersion): {$(GeneratedUpgradeCode)} from seed '$(UpgradeCodeSeedWithArch)'" Importance="high" />
  </Target>

  <!-- Pack target for CI compatibility -->
  <Target Name="Pack" DependsOnTargets="Build;PublishBundle">
    <Message Text="Bundle pack completed" Importance="high" />
  </Target>

</Project>



































